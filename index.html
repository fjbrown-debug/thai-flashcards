<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#6b4423">
    <title>Thai Vocabulary Flashcards</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;500;600;700&family=Nunito:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script>
        // Load theme immediately to prevent flash
        (function() {
            const savedTheme = localStorage.getItem('thaiFlashcardsTheme');
            if (savedTheme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
            }
        })();
    </script>
    <style>
        :root {
            /* Light theme (default) */
            --bg-primary: #fdfbf7;
            --bg-secondary: #f5ebe0;
            --bg-card: #ffffff;
            --bg-card-back: linear-gradient(135deg, #8b6f47 0%, #6b4423 100%);
            --text-primary: #6b4423;
            --text-secondary: #666666;
            --text-muted: #999999;
            --accent-primary: #d4a373;
            --accent-secondary: #8b6f47;
            --border-color: rgba(212, 163, 115, 0.3);
            --shadow-color: rgba(107, 68, 35, 0.12);
            --shadow-strong: rgba(107, 68, 35, 0.2);
            --card-border: rgba(139, 111, 71, 0.1);
            --btn-bg: #ffffff;
            --btn-nav-bg: #f5ebe0;
            --progress-bg: #e0e0e0;
            --modal-backdrop: rgba(0, 0, 0, 0.5);
            --success-color: #22c55e;
            --error-color: #ef4444;
            --glow-success: rgba(34, 197, 94, 0.4);
            --glow-error: rgba(239, 68, 68, 0.4);
        }

```
    [data-theme="dark"] {
        --bg-primary: #121214;
        --bg-secondary: #1c1c1f;
        --bg-card: #242428;
        --bg-card-back: linear-gradient(135deg, #3a3a42 0%, #28282d 100%);
        --text-primary: #e4e4e7;
        --text-secondary: #a1a1aa;
        --text-muted: #71717a;
        --accent-primary: #5eead4;
        --accent-secondary: #14b8a6;
        --border-color: rgba(161, 161, 170, 0.2);
        --shadow-color: rgba(0, 0, 0, 0.4);
        --shadow-strong: rgba(0, 0, 0, 0.6);
        --card-border: rgba(161, 161, 170, 0.1);
        --btn-bg: #242428;
        --btn-nav-bg: #2e2e33;
        --progress-bg: #2e2e33;
        --modal-backdrop: rgba(0, 0, 0, 0.75);
        --success-color: #4ade80;
        --error-color: #f87171;
        --glow-success: rgba(74, 222, 128, 0.3);
        --glow-error: rgba(248, 113, 113, 0.3);
    }

    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
    }

    body {
        font-family: 'Nunito', 'Sarabun', -apple-system, BlinkMacSystemFont, sans-serif;
        background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 15px;
        touch-action: pan-y;
        overflow-x: hidden;
        color: var(--text-primary);
        transition: background 0.3s ease, color 0.3s ease;
    }

    .container {
        max-width: 600px;
        width: 100%;
    }

    .header {
        text-align: center;
        margin-bottom: 12px;
    }

    .header-icon {
        font-size: 1.8em;
        margin-bottom: 4px;
        display: inline-block;
        animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-5px); }
    }

    h1 {
        text-align: center;
        color: var(--text-primary);
        margin-bottom: 4px;
        font-size: clamp(1.8em, 6vw, 2.5em);
        font-weight: 700;
        letter-spacing: -0.02em;
    }

    .subtitle {
        text-align: center;
        color: var(--text-secondary);
        margin-bottom: 12px;
        font-size: clamp(0.75em, 3vw, 0.9em);
        padding: 0 10px;
    }

    .list-selector-container {
        text-align: center;
        margin-bottom: 15px;
    }

    .list-selector {
        padding: 12px 20px;
        font-size: clamp(0.9em, 3.5vw, 1em);
        border: 2px solid var(--border-color);
        border-radius: 12px;
        background: var(--btn-bg);
        color: var(--text-primary);
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s;
        max-width: 100%;
        font-family: inherit;
    }

    .list-selector:focus {
        outline: none;
        border-color: var(--accent-primary);
        box-shadow: 0 0 0 3px rgba(212, 163, 115, 0.2);
    }

    .top-controls {
        display: flex;
        gap: 8px;
        margin-bottom: 15px;
        justify-content: space-between;
    }

    .settings-btn, .stats-btn {
        padding: 10px 16px;
        background: var(--btn-bg);
        border: 2px solid var(--border-color);
        border-radius: 12px;
        color: var(--text-primary);
        cursor: pointer;
        font-size: clamp(0.85em, 3vw, 0.95em);
        font-weight: 500;
        transition: all 0.2s;
        flex: 1;
    }

    .settings-btn:active, .stats-btn:active {
        background: var(--bg-secondary);
        transform: scale(0.98);
    }

    /* Theme toggle */
    .theme-toggle {
        position: fixed;
        top: 15px;
        right: 15px;
        background: var(--btn-bg);
        border: 2px solid var(--border-color);
        border-radius: 50%;
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 1.3em;
        z-index: 100;
        transition: all 0.3s;
        box-shadow: 0 4px 15px var(--shadow-color);
    }

    .theme-toggle:active {
        transform: scale(0.9);
    }

    .session-controls {
        display: flex;
        gap: 8px;
        margin-bottom: 15px;
    }

    .session-btn {
        flex: 1;
        padding: 10px 12px;
        border: 2px solid var(--border-color);
        background: var(--btn-bg);
        border-radius: 12px;
        color: var(--text-primary);
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-size: clamp(0.8em, 2.8vw, 0.9em);
    }

    .session-btn:active {
        transform: scale(0.95);
        background: var(--bg-secondary);
    }

    .session-btn.primary {
        background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
        color: white;
        border-color: transparent;
    }

    .session-btn.primary:disabled {
        background: var(--progress-bg);
        opacity: 0.5;
        cursor: not-allowed;
    }

    .session-btn.primary:disabled:active {
        transform: none;
    }

    .progress-container {
        margin-bottom: 15px;
    }

    .progress-info {
        display: flex;
        justify-content: space-between;
        color: var(--text-secondary);
        font-size: clamp(0.8em, 3vw, 0.9em);
        margin-bottom: 8px;
    }

    .progress-bar {
        width: 100%;
        height: 10px;
        background: var(--progress-bg);
        border-radius: 10px;
        overflow: visible;
        position: relative;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
        border-radius: 10px;
        transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        box-shadow: 0 2px 8px rgba(212, 163, 115, 0.4);
    }

    .progress-fill::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(180deg, rgba(255,255,255,0.3) 0%, transparent 50%);
        border-radius: 10px;
    }

    .progress-milestones {
        display: flex;
        justify-content: space-between;
        margin-top: 6px;
        padding: 0 2px;
    }

    .milestone {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--progress-bg);
        transition: all 0.3s;
        position: relative;
    }

    .milestone.reached {
        background: var(--accent-primary);
        box-shadow: 0 0 8px var(--accent-primary);
        animation: milestonePulse 4s ease-in-out infinite;
    }

    @keyframes milestonePulse {
        0%, 100% { 
            box-shadow: 0 0 6px var(--accent-primary);
            transform: scale(1);
        }
        50% { 
            box-shadow: 0 0 12px var(--accent-primary), 0 0 20px var(--accent-primary);
            transform: scale(1.15);
        }
    }

    .milestone.reached::after {
        content: '';
        position: absolute;
        top: -3px;
        left: -3px;
        right: -3px;
        bottom: -3px;
        border-radius: 50%;
        border: 2px solid var(--accent-primary);
        opacity: 0.5;
    }

    .card-container {
        perspective: 1000px;
        margin-bottom: 15px;
        position: relative;
    }

    .swipe-bar {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
        border-radius: 24px;
        opacity: 0;
        transition: opacity 0.15s ease;
        pointer-events: none;
        z-index: 5;
    }

    .swipe-bar.left {
        background: linear-gradient(90deg, rgba(239, 68, 68, 0.95) 0%, rgba(239, 68, 68, 0) 50%);
    }

    .swipe-bar.right {
        background: linear-gradient(-90deg, rgba(34, 197, 94, 0.95) 0%, rgba(34, 197, 94, 0) 50%);
    }

    .swipe-bar.visible {
        opacity: 1;
    }

    .swipe-hint {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        font-size: 3em;
        opacity: 0;
        transition: opacity 0.2s, transform 0.2s;
        pointer-events: none;
        z-index: 10;
        text-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .swipe-hint.left {
        left: 25px;
        color: white;
    }

    .swipe-hint.right {
        right: 25px;
        color: white;
    }

    .swipe-hint.visible {
        opacity: 1;
    }

    .swipe-hint.visible.left {
        transform: translateY(-50%) scale(1.2);
    }

    .swipe-hint.visible.right {
        transform: translateY(-50%) scale(1.2);
    }

    .card {
        width: 100%;
        min-height: clamp(280px, 50vh, 400px);
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        cursor: pointer;
        touch-action: none;
    }

    .card.flipped {
        transform: rotateY(180deg);
    }

    .card.swiping {
        transition: none;
    }

    /* Success/error feedback animations */
    .card.success-flash .card-face {
        animation: successPulse 0.4s ease;
    }

    .card.error-flash .card-face {
        animation: errorPulse 0.4s ease;
    }

    @keyframes successPulse {
        0%, 100% { box-shadow: 0 20px 60px var(--shadow-color); }
        50% { box-shadow: 0 0 40px var(--glow-success), 0 20px 60px var(--shadow-color); }
    }

    @keyframes errorPulse {
        0%, 100% { box-shadow: 0 20px 60px var(--shadow-color); }
        50% { box-shadow: 0 0 40px var(--glow-error), 0 20px 60px var(--shadow-color); }
    }

    .card-face {
        position: absolute;
        width: 100%;
        height: 100%;
        min-height: clamp(280px, 50vh, 400px);
        backface-visibility: hidden;
        border-radius: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        padding: clamp(20px, 8vw, 40px);
        box-shadow: 0 20px 60px var(--shadow-color), 0 8px 20px var(--shadow-color);
        transition: box-shadow 0.3s ease;
        overflow: hidden;
    }

    .card-front {
        background: var(--bg-card);
        border: 1px solid var(--card-border);
    }

    .card-back {
        background: var(--bg-card-back);
        transform: rotateY(180deg);
        position: relative;
        overflow: hidden;
    }

    .card-back::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 60%);
        pointer-events: none;
    }

    .card-text {
        font-size: clamp(2em, 8vw, 3.5em);
        font-weight: 600;
        color: var(--text-primary);
        word-break: keep-all;
        overflow-wrap: normal;
        max-width: 100%;
        line-height: 1.4;
        text-align: center;
        padding: 0 10px;
        font-family: 'Sarabun', 'Nunito', sans-serif;
        min-height: 1.4em;
    }

    .card-text.medium { font-size: clamp(1.5em, 6vw, 2.2em); }
    .card-text.small { font-size: clamp(1.2em, 5vw, 1.6em); }
    .card-text.tiny { font-size: clamp(1em, 4vw, 1.2em); }
    .card-text.xtiny { font-size: clamp(0.9em, 3.5vw, 1em); }

    .card-back .card-text {
        color: white;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }

    .controls {
        display: flex;
        gap: 8px;
        margin-bottom: 12px;
    }

    button {
        padding: clamp(12px, 3vw, 15px) clamp(16px, 4vw, 20px);
        border: none;
        border-radius: 14px;
        font-size: clamp(0.9em, 3.5vw, 1em);
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        flex: 1;
        touch-action: manipulation;
        font-family: inherit;
    }

    button:active:not(:disabled) {
        transform: scale(0.95);
    }

    button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
    }

    .btn-nav { 
        background: var(--btn-nav-bg); 
        color: var(--text-primary); 
    }
    
    .btn-flip { 
        background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%); 
        color: white;
        box-shadow: 0 4px 15px rgba(212, 163, 115, 0.3);
    }
    
    .btn-action { 
        background: var(--btn-bg); 
        color: var(--text-primary); 
        border: 2px solid var(--border-color); 
    }

    .action-controls {
        display: flex;
        gap: 8px;
    }

    .score-display {
        text-align: center;
        margin-bottom: 15px;
        font-size: clamp(1em, 3.5vw, 1.1em);
        color: var(--text-secondary);
        background: var(--btn-bg);
        padding: 12px 16px;
        border-radius: 14px;
        border: 1px solid var(--border-color);
    }

    .score-number { font-weight: 700; font-size: 1.3em; }
    .score-correct { color: var(--success-color); }
    .score-incorrect { color: var(--error-color); }

    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--modal-backdrop);
        z-index: 1000;
        align-items: center;
        justify-content: center;
        padding: 20px;
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
    }

    .modal.open { display: flex; }

    .modal-content {
        background: var(--bg-card);
        border-radius: 24px;
        padding: clamp(20px, 5vw, 30px);
        max-width: 500px;
        width: 100%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 25px 80px var(--shadow-strong);
        border: 1px solid var(--border-color);
        animation: modalSlideIn 0.3s ease;
    }

    @keyframes modalSlideIn {
        from {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }

    .modal-header h2 {
        color: var(--text-primary);
        font-size: clamp(1.3em, 5vw, 1.6em);
        font-weight: 700;
    }

    .close-btn {
        background: var(--btn-nav-bg);
        border: none;
        font-size: 1.2em;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 8px 12px;
        flex: none;
        border-radius: 10px;
        transition: all 0.2s;
    }

    .close-btn:active {
        transform: scale(0.9);
        background: var(--bg-secondary);
    }

    .modal-section {
        margin-bottom: 20px;
    }

    .modal-section h3 {
        color: var(--text-primary);
        margin-bottom: 10px;
        font-size: clamp(1em, 4vw, 1.1em);
        font-weight: 600;
    }

    .file-input-wrapper {
        position: relative;
        display: inline-block;
        width: 100%;
    }

    .file-input-label {
        display: block;
        padding: 12px 16px;
        background: var(--btn-bg);
        color: var(--text-primary);
        border: 2px solid var(--border-color);
        border-radius: 12px;
        cursor: pointer;
        text-align: center;
        font-weight: 500;
        font-size: clamp(0.9em, 3.5vw, 1em);
        transition: all 0.2s;
    }

    .file-input-label:active {
        background: var(--bg-secondary);
    }

    #csvFileInput { position: absolute; left: -9999px; }

    .import-info {
        margin-top: 8px;
        font-size: clamp(0.75em, 3vw, 0.85em);
        color: var(--text-muted);
    }

    .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 15px;
    }

    .stat-box {
        background: var(--bg-secondary);
        padding: 15px;
        border-radius: 14px;
        text-align: center;
        border: 1px solid var(--border-color);
    }

    .stat-value {
        font-size: clamp(1.5em, 6vw, 2em);
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: 5px;
    }

    .stat-label {
        font-size: clamp(0.8em, 3vw, 0.9em);
        color: var(--text-secondary);
    }

    .list-stat-item {
        background: var(--bg-secondary);
        padding: 15px;
        border-radius: 14px;
        margin-bottom: 12px;
        border: 1px solid var(--border-color);
    }

    .list-stat-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    .list-stat-name { font-weight: 600; color: var(--text-primary); font-size: 1em; }
    .list-stat-percent { font-size: 1.3em; font-weight: 700; color: var(--success-color); }

    .list-stat-bar {
        width: 100%;
        height: 8px;
        background: var(--progress-bg);
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 8px;
    }

    .list-stat-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--success-color) 0%, #22c55e 100%);
        transition: width 0.3s ease;
    }

    .list-stat-details {
        display: flex;
        justify-content: space-between;
        font-size: 0.85em;
        color: var(--text-secondary);
    }

    .stat-detail-item {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .stat-detail-value { font-weight: 600; color: var(--text-primary); }

    .mode-selector {
        display: flex;
        gap: 8px;
        margin-bottom: 15px;
    }

    .mode-btn {
        flex: 1;
        padding: 12px;
        border: 2px solid var(--border-color);
        background: var(--btn-bg);
        border-radius: 12px;
        color: var(--text-primary);
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        font-size: clamp(0.85em, 3vw, 0.95em);
    }

    .mode-btn.active {
        background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
        color: white;
        border-color: transparent;
    }

    .mode-btn:active { transform: scale(0.95); }

    .action-btn { width: 100%; margin-bottom: 10px; }

    .resume-modal-content { text-align: center; }

    .resume-modal-content p {
        margin-bottom: 20px;
        color: var(--text-secondary);
        font-size: 1em;
        line-height: 1.5;
    }

    .resume-modal-content .session-info {
        background: var(--bg-secondary);
        padding: 15px;
        border-radius: 14px;
        margin-bottom: 20px;
        border: 1px solid var(--border-color);
    }

    .resume-modal-content .session-info-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        font-size: 0.95em;
    }

    .resume-modal-content .session-info-item:last-child { margin-bottom: 0; }
    .resume-modal-content .session-info-label { color: var(--text-secondary); }
    .resume-modal-content .session-info-value { font-weight: 600; color: var(--text-primary); }

    .resume-buttons { display: flex; gap: 10px; }
    .resume-buttons button { flex: 1; }

    .toast {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%) translateY(20px);
        background: var(--text-primary);
        color: var(--bg-primary);
        padding: 14px 28px;
        border-radius: 14px;
        font-size: 0.95em;
        font-weight: 500;
        z-index: 2000;
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: none;
        box-shadow: 0 10px 40px var(--shadow-strong);
    }

    .toast.show { 
        opacity: 1; 
        transform: translateX(-50%) translateY(0);
    }

    /* Success/error toast variants */
    .toast.success {
        background: var(--success-color);
        color: white;
    }

    .toast.error {
        background: var(--error-color);
        color: white;
    }

    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 20px;
    }

    .empty-state-icon {
        font-size: 3em;
        margin-bottom: 15px;
        opacity: 0.8;
    }

    .empty-state-title {
        font-size: 1.2em;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 8px;
    }

    .empty-state-text {
        font-size: 0.95em;
        color: var(--text-secondary);
        line-height: 1.4;
    }

    .favorite-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        background: var(--bg-secondary);
        border: none;
        font-size: 1.5em;
        cursor: pointer;
        z-index: 15;
        padding: 8px;
        opacity: 0.7;
        transition: all 0.2s;
        flex: none;
        border-radius: 50%;
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .favorite-btn:active { transform: scale(1.15); }
    .favorite-btn.active { 
        opacity: 1; 
        background: #fef3c7;
    }

    [data-theme="dark"] .favorite-btn.active {
        background: #3f3f46;
    }

    @media (max-width: 480px) {
        body { padding: 10px; }
        .container { padding: 0; }
        .theme-toggle {
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
        }
    }
</style>
```

</head>
<body>
    <!-- Theme toggle button -->
    <button class="theme-toggle" id="themeToggle" title="Toggle dark mode">üåô</button>

```
<div class="container">
    <div class="header">
        <div class="header-icon">ü™∑</div>
        <h1>Thai Vocabulary</h1>
    </div>
    <p class="subtitle">Tap to flip ‚Ä¢ Swipe right for ‚úì ‚Ä¢ Swipe left for ‚úó</p>

    <div class="list-selector-container">
        <select class="list-selector" id="listSelector">
            <option value="0">List 1: Core Vocabulary (200 words)</option>
        </select>
        <div id="listProgressDisplay" style="text-align: center; margin-top: 8px; font-size: 0.9em; color: var(--text-primary); font-weight: 500;"></div>
    </div>

    <div class="top-controls">
        <button class="settings-btn" id="settingsBtn">‚öôÔ∏è Settings</button>
        <button class="stats-btn" id="statsBtn">üìä Stats</button>
    </div>

    <div class="session-controls">
        <button class="session-btn" id="restartBtn">üîÑ Restart</button>
    </div>

    <div class="mode-selector">
        <button class="mode-btn active" data-mode="all">All Cards</button>
        <button class="mode-btn" data-mode="review">Review Wrong</button>
    </div>

    <div class="progress-container">
        <div class="progress-info">
            <span id="cardCounter">Card 1 of 200</span>
            <span id="progressPercent">1%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-milestones" id="progressMilestones">
            <div class="milestone" data-percent="0"></div>
            <div class="milestone" data-percent="25"></div>
            <div class="milestone" data-percent="50"></div>
            <div class="milestone" data-percent="75"></div>
            <div class="milestone" data-percent="100"></div>
        </div>
    </div>

    <div class="card-container">
        <button class="favorite-btn" id="favoriteBtn" title="Add to favorites">‚òÜ</button>
        <div class="swipe-bar left" id="swipeBarLeft"></div>
        <div class="swipe-bar right" id="swipeBarRight"></div>
        <div class="swipe-hint left" id="swipeLeft">‚úó</div>
        <div class="swipe-hint right" id="swipeRight">‚úì</div>
        <div class="card" id="flashcard">
            <div class="card-face card-front">
                <div class="card-text" id="frontText"></div>
            </div>
            <div class="card-face card-back">
                <div class="card-text" id="backText"></div>
            </div>
        </div>
    </div>

    <div class="score-display">
        <span class="score-correct score-number" id="correctScore">0</span> correct ‚Ä¢ 
        <span class="score-incorrect score-number" id="incorrectScore">0</span> incorrect
    </div>

    <div class="controls">
        <button class="btn-nav" id="prevBtn">‚Üê Prev</button>
        <button class="btn-flip" id="flipBtn">Flip</button>
        <button class="btn-nav" id="nextBtn">Next ‚Üí</button>
    </div>

    <div class="action-controls">
        <button class="btn-action" id="shuffleBtn">üîÄ Shuffle</button>
        <button class="btn-action" id="toggleBtn">üîÑ Thai Front</button>
    </div>
</div>

<!-- Settings Modal -->
<div class="modal" id="settingsModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Settings</h2>
            <button class="close-btn" id="closeSettings">‚úï</button>
        </div>
        <div class="modal-section">
            <h3>Import Flashcards</h3>
            <div class="file-input-wrapper">
                <input type="file" id="csvFileInput" accept=".csv" />
                <label for="csvFileInput" class="file-input-label">üìÅ Choose CSV File</label>
            </div>
            <div class="import-info">CSV format: First column = Thai, Second column = English (with header row)</div>
        </div>
        <div class="modal-section">
            <h3>Data Management</h3>
            <button class="btn-action action-btn" id="exportBtn">üì§ Export Progress</button>
            <button class="btn-action action-btn" id="resetBtn">üîÑ Reset All Progress</button>
        </div>
    </div>
</div>

<!-- Stats Modal -->
<div class="modal" id="statsModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Statistics</h2>
            <button class="close-btn" id="closeStats">‚úï</button>
        </div>
        <div class="modal-section">
            <h3>Current List Progress</h3>
            <div id="currentListStats"></div>
        </div>
        <div class="modal-section">
            <h3>All Lists</h3>
            <div id="allListsStats"></div>
        </div>
        <div class="modal-section">
            <h3>Session Stats</h3>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-value" id="sessionCorrect">0</div>
                    <div class="stat-label">Correct</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="sessionIncorrect">0</div>
                    <div class="stat-label">Incorrect</div>
                </div>
            </div>
        </div>
        <div class="modal-section" style="font-size: 0.85em; color: var(--text-secondary); line-height: 1.5;">
            <strong>Learning Algorithm:</strong> A word is marked as "learned" after getting it correct 3 times in a row. If not reviewed within 7 days, it needs to be relearned.
        </div>
    </div>
</div>

<!-- Resume Modal -->
<div class="modal" id="resumeModal">
    <div class="modal-content resume-modal-content">
        <div class="modal-header" style="justify-content: center;">
            <h2>Session in Progress</h2>
        </div>
        <p>You have an unfinished session. Would you like to resume or start fresh?</p>
        <div class="session-info" id="sessionInfoDisplay">
            <div class="session-info-item">
                <span class="session-info-label">List:</span>
                <span class="session-info-value" id="resumeListName">-</span>
            </div>
            <div class="session-info-item">
                <span class="session-info-label">Progress:</span>
                <span class="session-info-value" id="resumeProgress">-</span>
            </div>
            <div class="session-info-item">
                <span class="session-info-label">Correct:</span>
                <span class="session-info-value score-correct" id="resumeCorrect">-</span>
            </div>
            <div class="session-info-item">
                <span class="session-info-label">Incorrect:</span>
                <span class="session-info-value score-incorrect" id="resumeIncorrect">-</span>
            </div>
        </div>
        <div class="resume-buttons">
            <button class="btn-action" id="startFreshBtn">Start Fresh</button>
            <button class="btn-flip" id="resumeSessionBtn">Resume</button>
        </div>
    </div>
</div>

<!-- Completion Modal -->
<div class="modal" id="completionModal">
    <div class="modal-content resume-modal-content">
        <div class="modal-header">
            <h2>üéâ List Complete!</h2>
            <button class="close-btn" id="closeCompletion">‚úï</button>
        </div>
        <p>Great job! You've finished all the cards in this list.</p>
        <div class="session-info">
            <div class="session-info-item">
                <span class="session-info-label">Cards reviewed:</span>
                <span class="session-info-value" id="completionTotal">-</span>
            </div>
            <div class="session-info-item">
                <span class="session-info-label">Correct:</span>
                <span class="session-info-value score-correct" id="completionCorrect">-</span>
            </div>
            <div class="session-info-item">
                <span class="session-info-label">Incorrect:</span>
                <span class="session-info-value score-incorrect" id="completionIncorrect">-</span>
            </div>
            <div class="session-info-item">
                <span class="session-info-label">Accuracy:</span>
                <span class="session-info-value" id="completionAccuracy">-</span>
            </div>
        </div>
        <div class="resume-buttons" style="flex-direction: column; gap: 10px;">
            <button class="btn-flip" id="restartListBtn">üîÑ Start Again</button>
            <button class="btn-action" id="reviewHardestBtn">üî• Review Hardest Cards</button>
        </div>
    </div>
</div>

<div class="toast" id="toast"></div>

<script>
    const vocabularyLists = [
        {
            name: "List 1: Core Vocabulary",
            words: [
                { thai: "‡∏ï‡∏∑‡πà‡∏ô‡∏ô‡∏≠‡∏ô", english: "to wake up" },
                { thai: "‡πÅ‡∏ï‡πà‡∏á‡∏ï‡∏±‡∏ß", english: "to get dressed" },
                { thai: "‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏ï‡∏±‡∏ß", english: "to prepare oneself" },
                { thai: "‡∏£‡∏µ‡∏ö", english: "to hurry" },
                { thai: "‡∏•‡πà‡∏≤‡∏ä‡πâ‡∏≤", english: "to be late/delayed" },
                { thai: "‡∏à‡∏≠‡∏á", english: "to book/reserve" },
                { thai: "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å", english: "to cancel" },
                { thai: "‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á", english: "to change/alter" },
                { thai: "‡πÄ‡∏´‡∏ô‡∏∑‡πà‡∏≠‡∏¢", english: "tired" },
                { thai: "‡πÄ‡∏ö‡∏∑‡πà‡∏≠", english: "bored" },
                { thai: "‡∏ï‡∏∑‡πà‡∏ô‡πÄ‡∏ï‡πâ‡∏ô", english: "excited" },
                { thai: "‡∏Å‡∏±‡∏á‡∏ß‡∏•", english: "worried/anxious" },
                { thai: "‡∏ú‡πà‡∏≠‡∏ô‡∏Ñ‡∏•‡∏≤‡∏¢", english: "relaxed" },
                { thai: "‡∏õ‡∏£‡∏∞‡∏´‡∏•‡∏≤‡∏î‡πÉ‡∏à", english: "surprised" },
                { thai: "‡∏ú‡∏¥‡∏î‡∏´‡∏ß‡∏±‡∏á", english: "disappointed" },
                { thai: "‡∏™‡∏∞‡∏î‡∏ß‡∏Å", english: "convenient" },
                { thai: "‡∏¢‡∏∏‡πà‡∏á‡∏¢‡∏≤‡∏Å", english: "complicated" },
                { thai: "‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°", english: "suitable/appropriate" },
                { thai: "‡πÅ‡∏≠‡∏≠‡∏±‡∏î", english: "crowded" },
                { thai: "‡∏™‡∏î‡πÉ‡∏´‡∏°‡πà", english: "fresh" },
                { thai: "‡πÄ‡∏™‡∏µ‡∏¢", english: "broken/spoiled" },
                { thai: "‡∏Ñ‡∏∏‡πâ‡∏°‡∏Ñ‡πà‡∏≤", english: "worthwhile/good value" },
                { thai: "‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠", english: "to contact" },
                { thai: "‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥", english: "to recommend/introduce" },
                { thai: "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å", english: "to choose" },
                { thai: "‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à", english: "to decide" },
                { thai: "‡πÅ‡∏ö‡πà‡∏á‡∏õ‡∏±‡∏ô", english: "to share" },
                { thai: "‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö", english: "to compare" },
                { thai: "‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î", english: "to save/economize" },
                { thai: "‡∏™‡πà‡∏ß‡∏ô‡∏ú‡∏™‡∏°", english: "ingredient" },
                { thai: "‡∏™‡∏π‡∏ï‡∏£", english: "recipe" },
                { thai: "‡∏£‡∏™‡∏ä‡∏≤‡∏ï‡∏¥", english: "taste/flavor" },
                { thai: "‡πÄ‡∏ú‡πá‡∏î", english: "spicy" },
                { thai: "‡∏´‡∏ß‡∏≤‡∏ô", english: "sweet" },
                { thai: "‡πÄ‡∏õ‡∏£‡∏µ‡πâ‡∏¢‡∏ß", english: "sour" },
                { thai: "‡∏ó‡∏≠‡∏î", english: "to fry" },
                { thai: "‡∏ï‡πâ‡∏°", english: "to boil" },
                { thai: "‡∏™‡∏ß‡∏¢", english: "beautiful" },
                { thai: "‡∏â‡∏•‡∏≤‡∏î", english: "smart/clever" },
                { thai: "‡∏™‡∏∞‡∏≠‡∏≤‡∏î", english: "clean" },
                { thai: "‡∏™‡∏Å‡∏õ‡∏£‡∏Å", english: "dirty" },
                { thai: "‡πÅ‡∏û‡∏á", english: "expensive" },
                { thai: "‡∏ñ‡∏π‡∏Å", english: "cheap" },
                { thai: "‡∏´‡∏ô‡∏≤‡∏ß", english: "cold" },
                { thai: "‡∏£‡πâ‡∏≠‡∏ô", english: "hot" },
                { thai: "‡∏™‡∏≠‡∏ô", english: "to teach" },
                { thai: "‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", english: "to learn" },
                { thai: "‡∏ó‡∏≥‡∏á‡∏≤‡∏ô", english: "to work" },
                { thai: "‡∏û‡∏π‡∏î", english: "to speak" },
                { thai: "‡∏ü‡∏±‡∏á", english: "to listen" },
                { thai: "‡∏≠‡πà‡∏≤‡∏ô", english: "to read" },
                { thai: "‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô", english: "to write" },
                { thai: "‡∏ã‡∏∑‡πâ‡∏≠", english: "to buy" },
                { thai: "‡∏Ç‡∏≤‡∏¢", english: "to sell" },
                { thai: "‡πÉ‡∏´‡πâ", english: "to give" },
                { thai: "‡∏£‡∏±‡∏ö", english: "to receive" },
                { thai: "‡∏™‡πà‡∏á", english: "to send" },
                { thai: "‡πÄ‡∏õ‡∏¥‡∏î", english: "to open" },
                { thai: "‡∏õ‡∏¥‡∏î", english: "to close" },
                { thai: "‡πÉ‡∏ä‡πâ", english: "to use" },
                { thai: "‡∏ã‡πà‡∏≠‡∏°", english: "to repair/fix" },
                { thai: "‡∏ó‡∏≥‡∏≠‡∏≤‡∏´‡∏≤‡∏£", english: "to cook" },
                { thai: "‡∏•‡πâ‡∏≤‡∏á", english: "to wash" },
                { thai: "‡∏ú‡∏™‡∏°", english: "to mix" },
                { thai: "‡∏´‡∏±‡πà‡∏ô", english: "to chop/cut" },
                { thai: "‡∏õ‡∏£‡∏∏‡∏á", english: "to season" },
                { thai: "‡∏ô‡∏∂‡πà‡∏á", english: "to steam" },
                { thai: "‡∏¢‡πà‡∏≤‡∏á", english: "to grill" },
                { thai: "‡∏≠‡∏ö", english: "to bake" },
                { thai: "‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÄ‡∏ó‡∏®", english: "spice" },
                { thai: "‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏õ‡∏£‡∏∏‡∏á", english: "seasoning" },
                { thai: "‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö", english: "ingredients" },
                { thai: "‡πÄ‡∏Ñ‡πá‡∏°", english: "salty" },
                { thai: "‡∏Ç‡∏°", english: "bitter" },
                { thai: "‡∏≠‡∏£‡πà‡∏≠‡∏¢", english: "delicious" },
                { thai: "‡πÄ‡∏´‡∏°‡πá‡∏ô", english: "smelly/stinky" },
                { thai: "‡∏´‡∏≠‡∏°", english: "fragrant" },
                { thai: "‡∏à‡∏∑‡∏î", english: "bland" },
                { thai: "‡∏Å‡∏£‡∏≠‡∏ö", english: "crispy" },
                { thai: "‡∏ô‡∏¥‡πà‡∏°", english: "soft" },
                { thai: "‡πÅ‡∏Ç‡πá‡∏á", english: "hard" },
                { thai: "‡πÄ‡∏´‡∏ô‡∏µ‡∏¢‡∏ß", english: "sticky/chewy" },
                { thai: "‡∏£‡∏ß‡∏î‡πÄ‡∏£‡πá‡∏ß", english: "fast/quick" },
                { thai: "‡∏ä‡πâ‡∏≤", english: "slow" },
                { thai: "‡∏á‡πà‡∏≤‡∏¢", english: "easy" },
                { thai: "‡∏¢‡∏≤‡∏Å", english: "difficult" },
                { thai: "‡∏™‡∏π‡∏á", english: "tall/high" },
                { thai: "‡πÄ‡∏ï‡∏µ‡πâ‡∏¢", english: "short" },
                { thai: "‡∏¢‡∏≤‡∏ß", english: "long" },
                { thai: "‡∏™‡∏±‡πâ‡∏ô", english: "short (length)" },
                { thai: "‡πÉ‡∏´‡∏ç‡πà", english: "big" },
                { thai: "‡πÄ‡∏•‡πá‡∏Å", english: "small" },
                { thai: "‡∏Å‡∏ß‡πâ‡∏≤‡∏á", english: "wide" },
                { thai: "‡πÅ‡∏Ñ‡∏ö", english: "narrow" },
                { thai: "‡∏´‡∏ô‡∏≤", english: "thick" },
                { thai: "‡∏ö‡∏≤‡∏á", english: "thin" },
                { thai: "‡πÄ‡∏Å‡πà‡∏≤", english: "old" },
                { thai: "‡πÉ‡∏´‡∏°‡πà", english: "new" },
                { thai: "‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏£‡∏á", english: "strong" },
                { thai: "‡∏≠‡πà‡∏≠‡∏ô‡πÅ‡∏≠", english: "weak" },
                { thai: "‡∏≠‡πâ‡∏ß‡∏ô", english: "fat" },
                { thai: "‡∏ú‡∏≠‡∏°", english: "thin/skinny" },
                { thai: "‡∏Ç‡∏¢‡∏±‡∏ô", english: "diligent/hardworking" },
                { thai: "‡∏Ç‡∏µ‡πâ‡πÄ‡∏Å‡∏µ‡∏¢‡∏à", english: "lazy" },
                { thai: "‡∏£‡∏ß‡∏¢", english: "rich" },
                { thai: "‡∏à‡∏ô", english: "poor" },
                { thai: "‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏µ‡∏¢‡∏á", english: "famous" },
                { thai: "‡πÄ‡∏á‡∏µ‡∏¢‡∏ö", english: "quiet" },
                { thai: "‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏î‡∏±‡∏á", english: "loud/noisy" },
                { thai: "‡∏™‡∏ô‡∏∏‡∏Å", english: "fun" },
                { thai: "‡∏ô‡πà‡∏≤‡πÄ‡∏ö‡∏∑‡πà‡∏≠", english: "boring" },
                { thai: "‡∏ô‡πà‡∏≤‡∏Å‡∏•‡∏±‡∏ß", english: "scary" },
                { thai: "‡∏ô‡πà‡∏≤‡∏£‡∏±‡∏Å", english: "cute" },
                { thai: "‡∏™‡∏ö‡∏≤‡∏¢", english: "comfortable" },
                { thai: "‡∏•‡∏≥‡∏ö‡∏≤‡∏Å", english: "difficult/troublesome" },
                { thai: "‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢", english: "dangerous" },
                { thai: "‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢", english: "safe" },
                { thai: "‡∏°‡∏∑‡∏î", english: "dark" },
                { thai: "‡∏™‡∏ß‡πà‡∏≤‡∏á", english: "bright" },
                { thai: "‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢", english: "neat/tidy" },
                { thai: "‡∏†‡∏π‡∏°‡∏¥‡πÉ‡∏à", english: "proud" },
                { thai: "‡∏≠‡∏±‡∏ö‡∏≠‡∏≤‡∏¢", english: "ashamed" },
                { thai: "‡πÇ‡∏Å‡∏£‡∏ò", english: "angry" },
                { thai: "‡πÄ‡∏™‡∏µ‡∏¢‡πÉ‡∏à", english: "sad/sorry" },
                { thai: "‡∏î‡∏µ‡πÉ‡∏à", english: "happy/glad" },
                { thai: "‡∏ï‡∏Å‡πÉ‡∏à", english: "shocked/startled" },
                { thai: "‡∏Å‡∏•‡∏±‡∏ß", english: "afraid/scared" },
                { thai: "‡∏Ñ‡∏¥‡∏î‡∏ñ‡∏∂‡∏á", english: "to miss (someone)" },
                { thai: "‡∏£‡∏±‡∏Å", english: "to love" },
                { thai: "‡πÄ‡∏Å‡∏•‡∏µ‡∏¢‡∏î", english: "to hate" },
                { thai: "‡∏ä‡∏≠‡∏ö", english: "to like" },
                { thai: "‡πÑ‡∏°‡πà‡∏ä‡∏≠‡∏ö", english: "to dislike" },
                { thai: "‡∏´‡∏ß‡∏±‡∏á", english: "to hope" },
                { thai: "‡πÄ‡∏ä‡∏∑‡πà‡∏≠", english: "to believe" },
                { thai: "‡∏™‡∏á‡∏™‡∏±‡∏¢", english: "to doubt/wonder" },
                { thai: "‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à", english: "to understand" },
                { thai: "‡∏™‡∏±‡∏ö‡∏™‡∏ô", english: "confused" },
                { thai: "‡∏à‡∏≥", english: "to remember" },
                { thai: "‡∏•‡∏∑‡∏°", english: "to forget" },
                { thai: "‡πÄ‡∏´‡πá‡∏ô", english: "to see" },
                { thai: "‡∏°‡∏≠‡∏á", english: "to look at" },
                { thai: "‡πÑ‡∏î‡πâ‡∏¢‡∏¥‡∏ô", english: "to hear" },
                { thai: "‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™", english: "to touch" },
                { thai: "‡∏ä‡∏¥‡∏°", english: "to taste" },
                { thai: "‡∏î‡∏°", english: "to smell" },
                { thai: "‡∏Ñ‡∏¥‡∏î", english: "to think" },
                { thai: "‡∏£‡∏π‡πâ‡∏™‡∏∂‡∏Å", english: "to feel" },
                { thai: "‡πÄ‡∏î‡∏¥‡∏ô", english: "to walk" },
                { thai: "‡∏ß‡∏¥‡πà‡∏á", english: "to run" },
                { thai: "‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î", english: "to jump" },
                { thai: "‡∏ô‡∏±‡πà‡∏á", english: "to sit" },
                { thai: "‡∏¢‡∏∑‡∏ô", english: "to stand" },
                { thai: "‡∏ô‡∏≠‡∏ô", english: "to lie down/sleep" },
                { thai: "‡∏ï‡∏∑‡πà‡∏ô", english: "to wake up" },
                { thai: "‡∏Å‡∏•‡∏±‡∏ö", english: "to return" },
                { thai: "‡∏°‡∏≤", english: "to come" },
                { thai: "‡πÑ‡∏õ", english: "to go" },
                { thai: "‡πÄ‡∏Ç‡πâ‡∏≤", english: "to enter" },
                { thai: "‡∏≠‡∏≠‡∏Å", english: "to exit/leave" },
                { thai: "‡∏Ç‡∏∂‡πâ‡∏ô", english: "to go up" },
                { thai: "‡∏•‡∏á", english: "to go down" },
                { thai: "‡∏ú‡πà‡∏≤‡∏ô", english: "to pass through" },
                { thai: "‡∏´‡∏¢‡∏∏‡∏î", english: "to stop" },
                { thai: "‡∏£‡∏≠", english: "to wait" },
                { thai: "‡πÄ‡∏£‡∏¥‡πà‡∏°", english: "to start/begin" },
                { thai: "‡∏à‡∏ö", english: "to finish/end" },
                { thai: "‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤", english: "to spend time" },
                { thai: "‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î‡πÄ‡∏ß‡∏•‡∏≤", english: "to save time" },
                { thai: "‡πÄ‡∏™‡∏µ‡∏¢‡πÄ‡∏ß‡∏•‡∏≤", english: "to waste time" },
                { thai: "‡πÄ‡∏£‡πá‡∏ß", english: "to be fast" },
                { thai: "‡∏ï‡∏£‡∏á‡πÄ‡∏ß‡∏•‡∏≤", english: "on time" },
                { thai: "‡∏™‡∏≤‡∏¢", english: "late" },
                { thai: "‡πÅ‡∏•‡πâ‡∏ß", english: "already" },
                { thai: "‡∏¢‡∏±‡∏á", english: "still/yet" },
                { thai: "‡∏Å‡∏≥‡∏•‡∏±‡∏á", english: "currently/in progress" },
                { thai: "‡∏à‡∏∞", english: "will (future)" },
                { thai: "‡πÄ‡∏Ñ‡∏¢", english: "used to/have done before" },
                { thai: "‡∏Ñ‡∏∏‡∏¢", english: "to chat/talk" },
                { thai: "‡∏û‡∏π‡∏î‡∏Ñ‡∏∏‡∏¢", english: "to converse" },
                { thai: "‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ô", english: "to talk together" },
                { thai: "‡πÄ‡∏•‡πà‡∏≤", english: "to tell/narrate" },
                { thai: "‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢", english: "to explain" },
                { thai: "‡∏ñ‡∏≤‡∏°", english: "to ask" },
                { thai: "‡∏ï‡∏≠‡∏ö", english: "to answer" },
                { thai: "‡∏ö‡∏≠‡∏Å", english: "to tell/inform" },
                { thai: "‡∏ä‡∏µ‡πâ‡πÅ‡∏à‡∏á", english: "to clarify" },
                { thai: "‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô", english: "to warn/remind" },
                { thai: "‡∏™‡∏±‡∏ç‡∏ç‡∏≤", english: "to promise" },
                { thai: "‡πÇ‡∏Å‡∏´‡∏Å", english: "to lie" },
                { thai: "‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°", english: "to try" },
                { thai: "‡∏ù‡∏∂‡∏Å‡∏ù‡∏ô", english: "to practice" },
                { thai: "‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ", english: "to learn (continuously)" },
                { thai: "‡∏®‡∏∂‡∏Å‡∏©‡∏≤", english: "to study" },
                { thai: "‡∏™‡∏≠‡∏ö", english: "to take a test" },
                { thai: "‡∏ú‡πà‡∏≤‡∏ô", english: "to pass (a test)" },
                { thai: "‡∏ï‡∏Å", english: "to fail" },
                { thai: "‡∏ó‡∏ö‡∏ó‡∏ß‡∏ô", english: "to review" },
                { thai: "‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ö‡πâ‡∏≤‡∏ô", english: "homework" },
                { thai: "‡∏Å‡∏≤‡∏£‡∏ö‡πâ‡∏≤‡∏ô", english: "homework" },
                { thai: "‡∏õ‡∏£‡∏¥‡∏ç‡∏ç‡∏≤", english: "degree" },
                { thai: "‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏•‡∏±‡∏¢", english: "college" },
                { thai: "‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏•‡∏±‡∏¢", english: "university" },
                { thai: "‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", english: "school" },
                { thai: "‡∏Ñ‡∏£‡∏π", english: "teacher" },
                { thai: "‡∏ô‡∏±‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", english: "student" },
                { thai: "‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", english: "classroom" },
                { thai: "‡∏™‡∏ô‡∏≤‡∏°‡∏Å‡∏µ‡∏¨‡∏≤", english: "sports field" },
                { thai: "‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏°‡∏∏‡∏î", english: "library" },
                { thai: "‡πÅ‡∏û‡∏ó‡∏¢‡πå", english: "doctor" },
                { thai: "‡∏û‡∏¢‡∏≤‡∏ö‡∏≤‡∏•", english: "nurse" },
                { thai: "‡πÇ‡∏£‡∏á‡∏û‡∏¢‡∏≤‡∏ö‡∏≤‡∏•", english: "hospital" },
                { thai: "‡∏¢‡∏≤", english: "medicine" },
                { thai: "‡∏õ‡πà‡∏ß‡∏¢", english: "sick/ill" },
                { thai: "‡∏´‡∏≤‡∏¢", english: "to recover/heal" },
                { thai: "‡∏ï‡∏£‡∏ß‡∏à", english: "to examine/check" },
                { thai: "‡∏£‡∏±‡∏Å‡∏©‡∏≤", english: "to treat/cure" },
                { thai: "‡∏≠‡∏≠‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏¢", english: "to exercise" },
                { thai: "‡∏û‡∏±‡∏Å‡∏ú‡πà‡∏≠‡∏ô", english: "to rest/relax" }
            ]
        },
        {
            name: "List 2: Travel, Weather & Shopping",
            words: [
                { thai: "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ", english: "hello/goodbye" },
                { thai: "‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì", english: "thank you" },
                { thai: "‡∏Ç‡∏≠‡πÇ‡∏ó‡∏©", english: "excuse me/sorry" },
                { thai: "‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏£", english: "never mind/no problem" },
                { thai: "‡∏ä‡πà‡∏ß‡∏¢‡πÑ‡∏î‡πâ‡πÑ‡∏´‡∏°", english: "can you help?" },
                { thai: "‡πÑ‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à", english: "don't understand" },
                { thai: "‡∏û‡∏π‡∏î‡∏ä‡πâ‡∏≤‡πÜ", english: "speak slowly" },
                { thai: "‡∏´‡πâ‡∏≠‡∏á‡∏ô‡πâ‡∏≥‡∏≠‡∏¢‡∏π‡πà‡πÑ‡∏´‡∏ô", english: "where is the bathroom?" },
                { thai: "‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà", english: "how much?" },
                { thai: "‡πÅ‡∏û‡∏á‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ", english: "too expensive" },
                { thai: "‡∏•‡∏î‡∏´‡∏ô‡πà‡∏≠‡∏¢", english: "discount please" },
                { thai: "‡∏ï‡∏•‡∏≤‡∏î", english: "market" },
                { thai: "‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤", english: "shop/store" },
                { thai: "‡∏´‡πâ‡∏≤‡∏á‡∏™‡∏£‡∏£‡∏û‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤", english: "department store/mall" },
                { thai: "‡∏£‡∏≤‡∏Ñ‡∏≤", english: "price" },
                { thai: "‡πÄ‡∏á‡∏¥‡∏ô", english: "money" },
                { thai: "‡∏ö‡∏≤‡∏ó", english: "baht (currency)" },
                { thai: "‡πÅ‡∏•‡∏Å‡πÄ‡∏á‡∏¥‡∏ô", english: "exchange money" },
                { thai: "‡∏ö‡∏±‡∏ï‡∏£‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï", english: "credit card" },
                { thai: "‡πÄ‡∏á‡∏¥‡∏ô‡∏™‡∏î", english: "cash" },
                { thai: "‡πÉ‡∏ö‡πÄ‡∏™‡∏£‡πá‡∏à", english: "receipt" },
                { thai: "‡∏Ç‡∏≠‡∏á‡∏Ç‡∏ß‡∏±‡∏ç", english: "gift/souvenir" },
                { thai: "‡∏Ç‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏•‡∏∂‡∏Å", english: "souvenir" },
                { thai: "‡∏≠‡∏≤‡∏Å‡∏≤‡∏®", english: "weather/air" },
                { thai: "‡∏ù‡∏ô", english: "rain" },
                { thai: "‡∏ù‡∏ô‡∏ï‡∏Å", english: "it's raining" },
                { thai: "‡πÅ‡∏î‡∏î", english: "sunlight" },
                { thai: "‡∏•‡∏°", english: "wind" },
                { thai: "‡πÄ‡∏°‡∏Ü", english: "cloud" },
                { thai: "‡∏ü‡πâ‡∏≤", english: "sky" },
                { thai: "‡∏û‡∏≤‡∏¢‡∏∏", english: "storm" },
                { thai: "‡∏ü‡πâ‡∏≤‡∏ú‡πà‡∏≤", english: "lightning" },
                { thai: "‡∏ü‡πâ‡∏≤‡∏£‡πâ‡∏≠‡∏á", english: "thunder" },
                { thai: "‡∏ô‡πâ‡∏≥‡∏ó‡πà‡∏ß‡∏°", english: "flood" },
                { thai: "‡∏ä‡∏∑‡πâ‡∏ô", english: "humid" },
                { thai: "‡πÅ‡∏´‡πâ‡∏á", english: "dry" },
                { thai: "‡∏´‡∏°‡∏≠‡∏Å", english: "fog" },
                { thai: "‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏î‡∏µ", english: "good weather" },
                { thai: "‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÅ‡∏¢‡πà", english: "bad weather" },
                { thai: "‡∏£‡πâ‡∏≠‡∏ô‡∏à‡∏±‡∏î", english: "very hot" },
                { thai: "‡∏´‡∏ô‡∏≤‡∏ß‡∏à‡∏±‡∏î", english: "very cold" },
                { thai: "‡∏≠‡∏ö‡∏≠‡πâ‡∏≤‡∏ß", english: "hot and humid" },
                { thai: "‡∏§‡∏î‡∏π", english: "season" },
                { thai: "‡∏§‡∏î‡∏π‡∏ù‡∏ô", english: "rainy season" },
                { thai: "‡∏§‡∏î‡∏π‡∏£‡πâ‡∏≠‡∏ô", english: "hot season" },
                { thai: "‡∏§‡∏î‡∏π‡∏´‡∏ô‡∏≤‡∏ß", english: "cool season" },
                { thai: "‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥", english: "temperature" },
                { thai: "‡∏≠‡∏á‡∏®‡∏≤", english: "degree (temperature)" },
                { thai: "‡πÇ‡∏£‡∏á‡πÅ‡∏£‡∏°", english: "hotel" },
                { thai: "‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏±‡∏Å", english: "room (hotel)" },
                { thai: "‡∏à‡∏≠‡∏á", english: "to book/reserve" },
                { thai: "‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏¥‡∏ô", english: "check in" },
                { thai: "‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏≠‡∏≤‡∏ó‡πå", english: "check out" },
                { thai: "‡∏Å‡∏∏‡∏ç‡πÅ‡∏à", english: "key" },
                { thai: "‡πÅ‡∏≠‡∏£‡πå", english: "air conditioner" },
                { thai: "‡∏û‡∏±‡∏î‡∏•‡∏°", english: "fan" },
                { thai: "‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏≤‡∏´‡∏≤‡∏£", english: "restaurant" },
                { thai: "‡πÄ‡∏°‡∏ô‡∏π", english: "menu" },
                { thai: "‡∏™‡∏±‡πà‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£", english: "to order food" },
                { thai: "‡πÄ‡∏ä‡πá‡∏Ñ‡∏ö‡∏¥‡∏•", english: "check/bill please" },
                { thai: "‡∏ó‡∏¥‡∏õ", english: "tip (gratuity)" },
                { thai: "‡∏´‡∏¥‡∏ß", english: "hungry" },
                { thai: "‡∏≠‡∏¥‡πà‡∏°", english: "full (not hungry)" },
                { thai: "‡∏Å‡∏£‡∏∞‡∏´‡∏≤‡∏¢", english: "thirsty" },
                { thai: "‡∏ô‡πâ‡∏≥‡πÄ‡∏õ‡∏•‡πà‡∏≤", english: "plain water" },
                { thai: "‡∏ô‡πâ‡∏≥‡πÅ‡∏Ç‡πá‡∏á", english: "ice" },
                { thai: "‡πÑ‡∏°‡πà‡πÄ‡∏≠‡∏≤‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•", english: "no sugar" },
                { thai: "‡πÑ‡∏°‡πà‡πÄ‡∏≠‡∏≤‡∏ô‡πâ‡∏≥‡πÅ‡∏Ç‡πá‡∏á", english: "no ice" },
                { thai: "‡∏£‡∏ñ‡πÅ‡∏ó‡πá‡∏Å‡∏ã‡∏µ‡πà", english: "taxi" },
                { thai: "‡∏£‡∏ñ‡∏ï‡∏π‡πâ", english: "van" },
                { thai: "‡∏£‡∏ñ‡∏ö‡∏±‡∏™", english: "bus" },
                { thai: "‡∏£‡∏ñ‡πÑ‡∏ü", english: "train" },
                { thai: "‡∏£‡∏ñ‡πÑ‡∏ü‡∏ü‡πâ‡∏≤", english: "skytrain/metro" },
                { thai: "‡πÄ‡∏£‡∏∑‡∏≠", english: "boat" },
                { thai: "‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ö‡∏¥‡∏ô", english: "airplane" },
                { thai: "‡∏™‡∏ô‡∏≤‡∏°‡∏ö‡∏¥‡∏ô", english: "airport" },
                { thai: "‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ", english: "station" },
                { thai: "‡∏õ‡πâ‡∏≤‡∏¢‡∏£‡∏ñ‡πÄ‡∏°‡∏•‡πå", english: "bus stop" },
                { thai: "‡∏ï‡∏±‡πã‡∏ß", english: "ticket" },
                { thai: "‡∏ã‡∏∑‡πâ‡∏≠‡∏ï‡∏±‡πã‡∏ß", english: "buy ticket" },
                { thai: "‡∏Ç‡∏∂‡πâ‡∏ô‡∏£‡∏ñ", english: "get on (vehicle)" },
                { thai: "‡∏•‡∏á‡∏£‡∏ñ", english: "get off (vehicle)" },
                { thai: "‡πÑ‡∏õ‡πÑ‡∏´‡∏ô", english: "where are you going?" },
                { thai: "‡∏ñ‡∏∂‡∏á", english: "to arrive" },
                { thai: "‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏ã‡πâ‡∏≤‡∏¢", english: "turn left" },
                { thai: "‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏Ç‡∏ß‡∏≤", english: "turn right" },
                { thai: "‡∏ï‡∏£‡∏á‡πÑ‡∏õ", english: "go straight" },
                { thai: "‡∏ä‡πâ‡∏≤‡∏´‡∏ô‡πà‡∏≠‡∏¢", english: "slow down" },
                { thai: "‡πÄ‡∏£‡πá‡∏ß‡∏´‡∏ô‡πà‡∏≠‡∏¢", english: "faster please" },
                { thai: "‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà", english: "here" },
                { thai: "‡∏ó‡∏µ‡πà‡∏ô‡∏±‡πà‡∏ô", english: "there" },
                { thai: "‡πÉ‡∏Å‡∏•‡πâ", english: "near/close" },
                { thai: "‡πÑ‡∏Å‡∏•", english: "far" },
                { thai: "‡∏´‡∏•‡∏á", english: "lost/get lost" },
                { thai: "‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà", english: "map" },
                { thai: "‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà", english: "address" },
                { thai: "‡∏ñ‡∏ô‡∏ô", english: "road/street" },
                { thai: "‡∏ã‡∏≠‡∏¢", english: "side street/alley" },
                { thai: "‡∏™‡∏∞‡∏û‡∏≤‡∏ô", english: "bridge" },
                { thai: "‡πÅ‡∏°‡πà‡∏ô‡πâ‡∏≥", english: "river" },
                { thai: "‡∏ó‡∏∞‡πÄ‡∏•", english: "sea/ocean" },
                { thai: "‡∏†‡∏π‡πÄ‡∏Ç‡∏≤", english: "mountain" },
                { thai: "‡∏õ‡πà‡∏≤", english: "forest/jungle" },
                { thai: "‡πÄ‡∏Å‡∏≤‡∏∞", english: "island" },
                { thai: "‡∏´‡∏≤‡∏î", english: "beach" },
                { thai: "‡∏ô‡πâ‡∏≥‡∏ï‡∏Å", english: "waterfall" },
                { thai: "‡∏ß‡∏±‡∏î", english: "temple" },
                { thai: "‡∏û‡∏£‡∏∞", english: "monk" },
                { thai: "‡∏û‡∏£‡∏∞‡∏û‡∏∏‡∏ó‡∏ò‡∏£‡∏π‡∏õ", english: "Buddha statue" },
                { thai: "‡∏û‡∏¥‡∏û‡∏¥‡∏ò‡∏†‡∏±‡∏ì‡∏ë‡πå", english: "museum" },
                { thai: "‡∏™‡∏ß‡∏ô‡∏™‡∏≤‡∏ò‡∏≤‡∏£‡∏ì‡∏∞", english: "park" },
                { thai: "‡∏™‡∏ß‡∏ô‡∏™‡∏±‡∏ï‡∏ß‡πå", english: "zoo" }
            ]
        }
    ];

    const LEARNING_THRESHOLD = 3;
    const REVIEW_DECAY_DAYS = 7;

    let currentListIndex = 0;
    let vocabulary = vocabularyLists[currentListIndex].words;
    let cards = [];
    let currentIndex = 0;
    let isFlipped = false;
    let showThaiFront = true;
    let currentMode = 'all';
    let cardStats = {};
    let sessionStats = { correct: 0, incorrect: 0, cardsReviewed: 0 };
    let sessionState = { cardOrder: [], currentIndex: 0, listIndex: 0, mode: 'all', inProgress: false };
    let favorites = new Set(); // Track favorited card keys
    let darkMode = false;

    // Special list indices (negative to distinguish from vocabulary lists)
    const FAVORITES_LIST = -1;
    const HARDEST_LIST = -2;

    let touchStartX = 0, touchStartY = 0, currentX = 0, isSwiping = false, lastTouchEnd = 0;

    const flashcard = document.getElementById('flashcard');
    const frontText = document.getElementById('frontText');
    const backText = document.getElementById('backText');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const flipBtn = document.getElementById('flipBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const toggleBtn = document.getElementById('toggleBtn');
    const cardCounter = document.getElementById('cardCounter');
    const progressPercent = document.getElementById('progressPercent');
    const progressFill = document.getElementById('progressFill');
    const correctScore = document.getElementById('correctScore');
    const incorrectScore = document.getElementById('incorrectScore');
    const csvFileInput = document.getElementById('csvFileInput');
    const settingsBtn = document.getElementById('settingsBtn');
    const statsBtn = document.getElementById('statsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const statsModal = document.getElementById('statsModal');
    const resumeModal = document.getElementById('resumeModal');
    const listSelector = document.getElementById('listSelector');
    const listProgressDisplay = document.getElementById('listProgressDisplay');
    const swipeLeft = document.getElementById('swipeLeft');
    const swipeRight = document.getElementById('swipeRight');
    const swipeBarLeft = document.getElementById('swipeBarLeft');
    const swipeBarRight = document.getElementById('swipeBarRight');
    const toast = document.getElementById('toast');
    const modeBtns = document.querySelectorAll('.mode-btn');
    const themeToggle = document.getElementById('themeToggle');

    function init() {
        loadProgress();
        loadTheme();
        updateListSelector();
        if (sessionState.inProgress && sessionState.cardOrder.length > 0) {
            showResumeModal();
        } else {
            initializeCards();
            updateCard();
        }
        setupEventListeners();
    }
    
    function loadTheme() {
        const savedTheme = localStorage.getItem('thaiFlashcardsTheme');
        if (savedTheme === 'dark') {
            darkMode = true;
            document.documentElement.setAttribute('data-theme', 'dark');
            themeToggle.textContent = '‚òÄÔ∏è';
        } else {
            darkMode = false;
            document.documentElement.removeAttribute('data-theme');
            themeToggle.textContent = 'üåô';
        }
    }
    
    function toggleTheme() {
        darkMode = !darkMode;
        if (darkMode) {
            document.documentElement.setAttribute('data-theme', 'dark');
            themeToggle.textContent = '‚òÄÔ∏è';
            localStorage.setItem('thaiFlashcardsTheme', 'dark');
        } else {
            document.documentElement.removeAttribute('data-theme');
            themeToggle.textContent = 'üåô';
            localStorage.setItem('thaiFlashcardsTheme', 'light');
        }
    }
    
    function updateMilestones(progress) {
        const milestones = document.querySelectorAll('.milestone');
        milestones.forEach(m => {
            const percent = parseInt(m.dataset.percent);
            if (progress >= percent) {
                m.classList.add('reached');
            } else {
                m.classList.remove('reached');
            }
        });
    }

    function setupEventListeners() {
        flashcard.addEventListener('click', () => { if (!isSwiping) flipCard(); });
        flashcard.addEventListener('touchstart', handleTouchStart, { passive: false });
        flashcard.addEventListener('touchmove', handleTouchMove, { passive: false });
        flashcard.addEventListener('touchend', handleTouchEnd);

        flipBtn.addEventListener('click', flipCard);
        prevBtn.addEventListener('click', prevCard);
        nextBtn.addEventListener('click', nextCard);
        shuffleBtn.addEventListener('click', shuffleCards);
        toggleBtn.addEventListener('click', toggleLanguage);

        document.getElementById('restartBtn').addEventListener('click', startFresh);
        
        // Theme toggle
        themeToggle.addEventListener('click', toggleTheme);

        settingsBtn.addEventListener('click', () => settingsModal.classList.add('open'));
        statsBtn.addEventListener('click', () => { updateStatsModal(); statsModal.classList.add('open'); });
        document.getElementById('closeSettings').addEventListener('click', () => settingsModal.classList.remove('open'));
        document.getElementById('closeStats').addEventListener('click', () => statsModal.classList.remove('open'));

        document.getElementById('startFreshBtn').addEventListener('click', () => { resumeModal.classList.remove('open'); startFresh(); });
        document.getElementById('resumeSessionBtn').addEventListener('click', () => { resumeModal.classList.remove('open'); resumeSession(); });
        
        // Completion modal handlers
        document.getElementById('closeCompletion').addEventListener('click', () => document.getElementById('completionModal').classList.remove('open'));
        document.getElementById('restartListBtn').addEventListener('click', () => {
            document.getElementById('completionModal').classList.remove('open');
            startFresh();
        });
        document.getElementById('reviewHardestBtn').addEventListener('click', () => {
            document.getElementById('completionModal').classList.remove('open');
            sessionStats = { correct: 0, incorrect: 0, cardsReviewed: 0 };
            listSelector.value = HARDEST_LIST;
            switchList(HARDEST_LIST);
        });

        csvFileInput.addEventListener('change', handleFileUpload);
        listSelector.addEventListener('change', (e) => switchList(parseInt(e.target.value)));
        document.getElementById('exportBtn').addEventListener('click', exportProgress);
        document.getElementById('resetBtn').addEventListener('click', resetProgress);

        modeBtns.forEach(btn => btn.addEventListener('click', () => switchMode(btn.dataset.mode)));
        document.addEventListener('keydown', handleKeyboard);
        
        // Favorite button
        document.getElementById('favoriteBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            toggleFavorite();
        });

        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd < 300) e.preventDefault();
            lastTouchEnd = now;
        }, false);

        window.addEventListener('click', (e) => {
            if (e.target === settingsModal) settingsModal.classList.remove('open');
            if (e.target === statsModal) statsModal.classList.remove('open');
            // Don't allow closing resume modal by clicking outside - user must choose
            if (e.target.id === 'completionModal') e.target.classList.remove('open');
        });
    }

    function handleTouchStart(e) {
        if (e.touches.length > 1) return;
        touchStartX = currentX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        isSwiping = false;
    }

    function handleTouchMove(e) {
        if (!touchStartX) return;
        currentX = e.touches[0].clientX;
        const diffX = currentX - touchStartX;
        const diffY = e.touches[0].clientY - touchStartY;

        if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
            e.preventDefault();
            isSwiping = true;
            flashcard.classList.add('swiping');
            flashcard.style.transform = `translateX(${diffX}px) rotateY(${isFlipped ? 180 : 0}deg)`;

            const intensity = Math.min(Math.abs(diffX) / 100, 1);

            if (diffX > 30) {
                swipeRight.classList.add('visible');
                swipeBarRight.classList.add('visible');
                swipeBarRight.style.opacity = intensity;
                swipeLeft.classList.remove('visible');
                swipeBarLeft.classList.remove('visible');
            } else if (diffX < -30) {
                swipeLeft.classList.add('visible');
                swipeBarLeft.classList.add('visible');
                swipeBarLeft.style.opacity = intensity;
                swipeRight.classList.remove('visible');
                swipeBarRight.classList.remove('visible');
            } else {
                swipeLeft.classList.remove('visible');
                swipeRight.classList.remove('visible');
                swipeBarLeft.classList.remove('visible');
                swipeBarRight.classList.remove('visible');
            }
        }
    }

    function handleTouchEnd() {
        if (!touchStartX) return;
        const diffX = currentX - touchStartX;

        swipeLeft.classList.remove('visible');
        swipeRight.classList.remove('visible');
        swipeBarLeft.classList.remove('visible');
        swipeBarRight.classList.remove('visible');
        swipeBarLeft.style.opacity = '';
        swipeBarRight.style.opacity = '';
        flashcard.classList.remove('swiping');
        flashcard.style.transform = '';

        if (Math.abs(diffX) > 100) {
            diffX > 0 ? markCorrect() : markIncorrect();
        }

        touchStartX = currentX = 0;
        setTimeout(() => { isSwiping = false; }, 100);
    }

    function handleKeyboard(e) {
        if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); flipCard(); }
        else if (e.key === 'ArrowRight') { e.preventDefault(); markCorrect(); }
        else if (e.key === 'ArrowLeft') { e.preventDefault(); markIncorrect(); }
    }

    function initializeCards() {
        if (currentMode === 'review') {
            const listStats = getListStats(currentListIndex);
            cards = vocabulary.filter(c => {
                const stat = listStats[getCardKey(c)];
                return stat && stat.incorrect > 0;
            });
            if (cards.length === 0) {
                showToast('No incorrect cards to review!');
                switchMode('all');
                return;
            }
            cards.sort((a, b) => (getListStats(currentListIndex)[getCardKey(b)]?.incorrect || 0) - (getListStats(currentListIndex)[getCardKey(a)]?.incorrect || 0));
        } else {
            cards = [...vocabulary].sort(() => Math.random() - 0.5);
        }
        currentIndex = 0;
        saveSessionState();
    }
    
    function initializeCardsPreservePosition(oldCard) {
        const oldKey = oldCard ? getCardKey(oldCard) : null;
        
        if (currentMode === 'review') {
            const listStats = getListStats(currentListIndex);
            // Filter to only incorrect cards, maintaining current order where possible
            const incorrectCards = vocabulary.filter(c => {
                const stat = listStats[getCardKey(c)];
                return stat && stat.incorrect > 0;
            });
            
            if (incorrectCards.length === 0) {
                showToast('No incorrect cards to review!');
                currentMode = 'all';
                modeBtns.forEach(b => b.classList.toggle('active', b.dataset.mode === 'all'));
                // Keep current cards as-is if already have cards
                if (!cards.length) {
                    cards = [...vocabulary].sort(() => Math.random() - 0.5);
                }
            } else {
                // Sort by most incorrect first
                cards = incorrectCards.sort((a, b) => 
                    (listStats[getCardKey(b)]?.incorrect || 0) - (listStats[getCardKey(a)]?.incorrect || 0)
                );
            }
        } else {
            // Switching to "All Cards" - keep existing order, just ensure all cards are included
            if (cards.length === 0) {
                cards = [...vocabulary].sort(() => Math.random() - 0.5);
            } else {
                // Preserve order of cards we already have, add any missing ones at the end
                const currentKeys = new Set(cards.map(c => getCardKey(c)));
                const missingCards = vocabulary.filter(c => !currentKeys.has(getCardKey(c)));
                // Only add missing cards if we're expanding from review mode
                if (missingCards.length > 0) {
                    cards = [...cards.filter(c => vocabulary.includes(c)), ...missingCards];
                }
            }
        }
        
        // Try to find the old card in the new list
        if (oldKey) {
            const newIndex = cards.findIndex(c => getCardKey(c) === oldKey);
            currentIndex = newIndex >= 0 ? newIndex : Math.min(currentIndex, cards.length - 1);
        } else {
            currentIndex = Math.min(currentIndex, Math.max(0, cards.length - 1));
        }
        
        saveSessionState();
    }

    function getCardKey(card) { return `${card.thai}|${card.english}`; }
    function getListStats(idx) { if (!cardStats[idx]) cardStats[idx] = {}; return cardStats[idx]; }

    function getListProgress(idx) {
        const list = vocabularyLists[idx], stats = getListStats(idx);
        let learned = 0, reviewed = 0, totalCorrect = 0, totalIncorrect = 0;
        list.words.forEach(c => {
            const s = stats[getCardKey(c)];
            if (s) {
                reviewed++;
                totalCorrect += s.correct || 0;
                totalIncorrect += s.incorrect || 0;
                if (s.consecutiveCorrect >= LEARNING_THRESHOLD) learned++;
            }
        });
        return { total: list.words.length, learned, reviewed, learnedPercent: Math.round((learned / list.words.length) * 100), totalCorrect, totalIncorrect };
    }

    function updateCard() {
        if (!cards.length) { 
            // Show friendly empty state based on current list/mode
            let icon, title, text;
            
            if (currentListIndex === FAVORITES_LIST) {
                icon = '‚≠ê';
                title = 'No Favorites Yet';
                text = 'Tap the ‚òÜ on any card to add it to your favorites.';
            } else if (currentListIndex === HARDEST_LIST) {
                icon = 'üéâ';
                title = 'No Hard Cards';
                text = "You haven't gotten any cards wrong yet. Keep practicing!";
            } else if (currentMode === 'review') {
                icon = '‚ú®';
                title = 'Nothing to Review';
                text = "You haven't marked any cards as incorrect. Great job!";
            } else {
                icon = 'üìö';
                title = 'No Cards';
                text = 'This list is empty.';
            }
            
            frontText.innerHTML = `<div class="empty-state">
                <div class="empty-state-icon">${icon}</div>
                <div class="empty-state-title">${title}</div>
                <div class="empty-state-text">${text}</div>
            </div>`;
            backText.innerHTML = frontText.innerHTML;
            
            cardCounter.textContent = 'Card 0 of 0';
            progressPercent.textContent = '0%';
            progressFill.style.width = '0%';
            prevBtn.disabled = true;
            nextBtn.disabled = true;
            
            return; 
        }
        const card = cards[currentIndex];
        frontText.textContent = showThaiFront ? card.thai : card.english;
        backText.textContent = showThaiFront ? card.english : card.thai;
        applyFontSize(frontText);
        applyFontSize(backText);

        const progress = ((currentIndex + 1) / cards.length) * 100;
        cardCounter.textContent = `Card ${currentIndex + 1} of ${cards.length}`;
        progressPercent.textContent = `${Math.round(progress)}%`;
        progressFill.style.width = `${progress}%`;
        updateMilestones(progress);
        prevBtn.disabled = currentIndex === 0;
        nextBtn.disabled = currentIndex === cards.length - 1;
        
        // Update favorite button
        const isFav = favorites.has(getCardKey(card));
        const favBtn = document.getElementById('favoriteBtn');
        favBtn.textContent = isFav ? '‚òÖ' : '‚òÜ';
        favBtn.classList.toggle('active', isFav);
        
        updateScoreDisplay();
    }

    function applyFontSize(el) {
        const len = el.textContent.length;
        el.className = 'card-text' + (len > 40 ? ' xtiny' : len > 25 ? ' tiny' : len > 18 ? ' small' : len > 10 ? ' medium' : '');
    }

    function flipCard() { isFlipped = !isFlipped; flashcard.classList.toggle('flipped'); }
    
    function nextCard() { 
        if (currentIndex < cards.length - 1) { 
            // First flip back if needed (without animation)
            if (isFlipped) { 
                flashcard.style.transition = 'none';
                flashcard.classList.remove('flipped'); 
                isFlipped = false;
                // Force reflow then restore transition
                flashcard.offsetHeight;
                flashcard.style.transition = '';
            } 
            currentIndex++; 
            updateCard(); 
            saveSessionState(); 
        } 
    }
    
    function prevCard() { 
        if (currentIndex > 0) { 
            if (isFlipped) { 
                flashcard.style.transition = 'none';
                flashcard.classList.remove('flipped'); 
                isFlipped = false;
                flashcard.offsetHeight;
                flashcard.style.transition = '';
            } 
            currentIndex--; 
            updateCard(); 
            saveSessionState(); 
        } 
    }
    function shuffleCards() { 
        sessionStats = { correct: 0, incorrect: 0, cardsReviewed: 0 };
        initializeCards(); 
        if (isFlipped) { flashcard.classList.remove('flipped'); isFlipped = false; } 
        updateCard(); 
        showToast('Cards shuffled!'); 
    }
    function toggleLanguage() { showThaiFront = !showThaiFront; toggleBtn.textContent = `üîÑ ${showThaiFront ? 'Thai' : 'English'} Front`; if (isFlipped) { flashcard.classList.remove('flipped'); isFlipped = false; } updateCard(); saveProgress(); }
    
    function toggleFavorite() {
        if (!cards.length) return;
        const card = cards[currentIndex];
        const key = getCardKey(card);
        
        if (favorites.has(key)) {
            favorites.delete(key);
            showToast('Removed from favorites');
        } else {
            favorites.add(key);
            showToast('Added to favorites ‚≠ê');
        }
        
        updateCard();
        updateListSelector();
        saveProgress();
    }

    function markCorrect() {
        if (!cards.length) return;
        const card = cards[currentIndex];
        const key = getCardKey(card);
        
        // Flash animation
        flashcard.classList.add('success-flash');
        setTimeout(() => flashcard.classList.remove('success-flash'), 400);
        
        // Find which list this card belongs to and update stats there
        const originalListIdx = findCardOriginalList(card);
        const stats = getListStats(originalListIdx);
        
        if (!stats[key]) stats[key] = { correct: 0, incorrect: 0, consecutiveCorrect: 0, lastReviewed: null };
        stats[key].correct++;
        stats[key].consecutiveCorrect++;
        stats[key].lastReviewed = new Date().toISOString();
        sessionStats.correct++;
        if (stats[key].consecutiveCorrect === LEARNING_THRESHOLD) showToast('üéâ Word learned!', 'success');
        updateScoreDisplay();
        saveProgress();
        
        if (currentIndex < cards.length - 1) {
            nextCard();
        } else {
            showCompletionModal();
        }
    }

    function markIncorrect() {
        if (!cards.length) return;
        const card = cards[currentIndex];
        const key = getCardKey(card);
        
        // Flash animation
        flashcard.classList.add('error-flash');
        setTimeout(() => flashcard.classList.remove('error-flash'), 400);
        
        // Find which list this card belongs to and update stats there
        const originalListIdx = findCardOriginalList(card);
        const stats = getListStats(originalListIdx);
        
        if (!stats[key]) stats[key] = { correct: 0, incorrect: 0, consecutiveCorrect: 0, lastReviewed: null };
        stats[key].incorrect++;
        stats[key].consecutiveCorrect = 0;
        stats[key].lastReviewed = new Date().toISOString();
        sessionStats.incorrect++;
        updateScoreDisplay();
        saveProgress();
        
        if (currentIndex < cards.length - 1) {
            nextCard();
        } else {
            showCompletionModal();
        }
    }
    
    function findCardOriginalList(card) {
        const key = getCardKey(card);
        for (let i = 0; i < vocabularyLists.length; i++) {
            if (vocabularyLists[i].words.some(c => getCardKey(c) === key)) {
                return i;
            }
        }
        return 0; // Default to first list if not found
    }
    
    function showCompletionModal() {
        sessionState.inProgress = false;
        saveSessionState();
        
        const total = sessionStats.correct + sessionStats.incorrect;
        const accuracy = total > 0 ? Math.round((sessionStats.correct / total) * 100) : 0;
        
        document.getElementById('completionTotal').textContent = total;
        document.getElementById('completionCorrect').textContent = sessionStats.correct;
        document.getElementById('completionIncorrect').textContent = sessionStats.incorrect;
        document.getElementById('completionAccuracy').textContent = `${accuracy}%`;
        
        document.getElementById('completionModal').classList.add('open');
    }

    function updateScoreDisplay() {
        // Show session stats (not all-time stats)
        correctScore.textContent = sessionStats.correct;
        incorrectScore.textContent = sessionStats.incorrect;
        
        // Update list progress display
        if (currentListIndex >= 0) {
            const p = getListProgress(currentListIndex);
            listProgressDisplay.textContent = `${p.learned} of ${p.total} learned (${p.learnedPercent}%)`;
        } else if (currentListIndex === FAVORITES_LIST) {
            listProgressDisplay.textContent = `${favorites.size} favorites`;
        } else if (currentListIndex === HARDEST_LIST) {
            listProgressDisplay.textContent = `${cards.length} hardest cards`;
        }
    }

    function switchMode(mode) {
        currentMode = mode;
        modeBtns.forEach(b => b.classList.toggle('active', b.dataset.mode === mode));
        // Don't reset position - keep current index if possible
        const oldIndex = currentIndex;
        const oldCard = cards[currentIndex];
        initializeCardsPreservePosition(oldCard);
        if (isFlipped) { flashcard.classList.remove('flipped'); isFlipped = false; }
        updateCard();
        saveProgress();
    }

    function switchList(idx) {
        const oldCard = cards.length > 0 ? cards[currentIndex] : null;
        currentListIndex = idx;
        
        if (idx === FAVORITES_LIST) {
            vocabulary = getFavoriteCards();
            if (vocabulary.length === 0) {
                // Don't redirect, just show empty state
                cards = [];
                currentIndex = 0;
                if (isFlipped) { flashcard.classList.remove('flipped'); isFlipped = false; }
                updateCard();
                saveProgress();
                return;
            }
        } else if (idx === HARDEST_LIST) {
            const hardest = getHardestCards();
            vocabulary = hardest.map(h => h.card);
            if (vocabulary.length === 0) {
                // Don't redirect, just show empty state
                cards = [];
                currentIndex = 0;
                if (isFlipped) { flashcard.classList.remove('flipped'); isFlipped = false; }
                updateCard();
                saveProgress();
                return;
            }
        } else {
            vocabulary = vocabularyLists[idx].words;
        }
        
        // Preserve position - use initializeCardsPreservePosition
        initializeCardsPreservePosition(oldCard);
        if (isFlipped) { flashcard.classList.remove('flipped'); isFlipped = false; }
        updateCard();
        saveProgress();
    }

    function updateListSelector() {
        listSelector.innerHTML = '';
        
        // Add Favorites option
        const favOption = document.createElement('option');
        favOption.value = FAVORITES_LIST;
        favOption.textContent = `‚≠ê Favorites (${favorites.size} words)`;
        listSelector.appendChild(favOption);
        
        // Add Hardest Cards option
        const hardOption = document.createElement('option');
        hardOption.value = HARDEST_LIST;
        const hardestCount = getHardestCards().length;
        hardOption.textContent = `üî• Hardest Cards (${hardestCount} words)`;
        listSelector.appendChild(hardOption);
        
        // Add separator
        const separator = document.createElement('option');
        separator.disabled = true;
        separator.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
        listSelector.appendChild(separator);
        
        // Add vocabulary lists
        vocabularyLists.forEach((l, i) => {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = `${l.name} (${l.words.length} words)`;
            listSelector.appendChild(option);
        });
        
        listSelector.value = currentListIndex;
    }
    
    function getHardestCards() {
        // Get all cards with incorrect counts across all lists
        const allCardsWithStats = [];
        
        vocabularyLists.forEach((list, listIdx) => {
            list.words.forEach(card => {
                const key = getCardKey(card);
                const stats = cardStats[listIdx]?.[key];
                if (stats && stats.incorrect > 0) {
                    allCardsWithStats.push({
                        card,
                        incorrect: stats.incorrect,
                        listIdx
                    });
                }
            });
        });
        
        // Sort by incorrect count (highest first) and take top 30
        allCardsWithStats.sort((a, b) => b.incorrect - a.incorrect);
        return allCardsWithStats.slice(0, 30);
    }
    
    function getFavoriteCards() {
        const favCards = [];
        vocabularyLists.forEach(list => {
            list.words.forEach(card => {
                if (favorites.has(getCardKey(card))) {
                    favCards.push(card);
                }
            });
        });
        return favCards;
    }

    function saveSessionState() {
        sessionState = { cardOrder: cards.map(getCardKey), currentIndex, listIndex: currentListIndex, mode: currentMode, inProgress: currentIndex < cards.length - 1 && cards.length > 0 };
        localStorage.setItem('thaiFlashcardsSession', JSON.stringify(sessionState));
    }

    function showResumeModal() {
        document.getElementById('resumeListName').textContent = vocabularyLists[sessionState.listIndex]?.name || 'Unknown';
        document.getElementById('resumeProgress').textContent = `Card ${sessionState.currentIndex + 1} of ${sessionState.cardOrder.length}`;
        document.getElementById('resumeCorrect').textContent = sessionStats.correct;
        document.getElementById('resumeIncorrect').textContent = sessionStats.incorrect;
        resumeModal.classList.add('open');
    }

    function startFresh() {
        sessionStats = { correct: 0, incorrect: 0, cardsReviewed: 0 };
        initializeCards();
        if (isFlipped) { flashcard.classList.remove('flipped'); isFlipped = false; }
        updateCard();
        updateSessionScoreDisplay();
        showToast('Started fresh session!');
    }
    
    function updateSessionScoreDisplay() {
        correctScore.textContent = sessionStats.correct;
        incorrectScore.textContent = sessionStats.incorrect;
    }

    function resumeSession() {
        if (sessionState.cardOrder.length) {
            currentListIndex = sessionState.listIndex;
            vocabulary = vocabularyLists[currentListIndex].words;
            listSelector.value = currentListIndex;
            currentMode = sessionState.mode;
            modeBtns.forEach(b => b.classList.toggle('active', b.dataset.mode === currentMode));
            const map = new Map(vocabulary.map(c => [getCardKey(c), c]));
            cards = sessionState.cardOrder.map(k => map.get(k)).filter(Boolean);
            currentIndex = Math.min(sessionState.currentIndex, cards.length - 1);
            if (isFlipped) { flashcard.classList.remove('flipped'); isFlipped = false; }
            updateCard();
            showToast('Session resumed!');
        } else startFresh();
    }

    function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            const lines = ev.target.result.split('\n').filter(l => l.trim());
            const newCards = [];
            for (let i = 1; i < lines.length; i++) {
                const m = lines[i].match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g);
                if (m?.length >= 2) {
                    const thai = m[0].replace(/^"|"$/g, '').trim();
                    const english = m[1].replace(/^"|"$/g, '').trim();
                    if (thai && english) newCards.push({ thai, english });
                }
            }
            if (!newCards.length) { showToast('No valid cards found'); return; }
            const existing = new Set(vocabulary.map(c => c.thai.toLowerCase() + '|' + c.english.toLowerCase()));
            const unique = newCards.filter(c => !existing.has(c.thai.toLowerCase() + '|' + c.english.toLowerCase()));
            if (!unique.length) { showToast('All cards are duplicates'); csvFileInput.value = ''; return; }
            vocabulary.push(...unique);
            initializeCards();
            updateCard();
            saveProgress();
            showToast(`Imported ${unique.length} new cards!`);
            csvFileInput.value = '';
        };
        reader.readAsText(file);
    }

    function updateStatsModal() {
        document.getElementById('sessionCorrect').textContent = sessionStats.correct;
        document.getElementById('sessionIncorrect').textContent = sessionStats.incorrect;
        const cp = getListProgress(currentListIndex);
        document.getElementById('currentListStats').innerHTML = `
            <div class="list-stat-item">
                <div class="list-stat-header"><span class="list-stat-name">${vocabularyLists[currentListIndex].name}</span><span class="list-stat-percent">${cp.learnedPercent}%</span></div>
                <div class="list-stat-bar"><div class="list-stat-bar-fill" style="width:${cp.learnedPercent}%"></div></div>
                <div class="list-stat-details">
                    <div class="stat-detail-item"><span class="stat-detail-value">${cp.learned}/${cp.total}</span><span>Learned</span></div>
                    <div class="stat-detail-item"><span class="stat-detail-value">${cp.reviewed}</span><span>Reviewed</span></div>
                    <div class="stat-detail-item"><span class="stat-detail-value score-correct">${cp.totalCorrect}</span><span>Correct</span></div>
                    <div class="stat-detail-item"><span class="stat-detail-value score-incorrect">${cp.totalIncorrect}</span><span>Wrong</span></div>
                </div>
            </div>`;
        document.getElementById('allListsStats').innerHTML = vocabularyLists.map((l, i) => {
            const p = getListProgress(i);
            return `<div class="list-stat-item">
                <div class="list-stat-header"><span class="list-stat-name">${l.name}</span><span class="list-stat-percent">${p.learnedPercent}%</span></div>
                <div class="list-stat-bar"><div class="list-stat-bar-fill" style="width:${p.learnedPercent}%"></div></div>
                <div class="list-stat-details">
                    <div class="stat-detail-item"><span class="stat-detail-value">${p.learned}/${p.total}</span><span>Learned</span></div>
                    <div class="stat-detail-item"><span class="stat-detail-value">${p.reviewed}</span><span>Reviewed</span></div>
                </div>
            </div>`;
        }).join('');
    }

    function exportProgress() {
        const data = { version: 1, exportDate: new Date().toISOString(), cardStats, sessionStats, currentListIndex, showThaiFront, currentMode, favorites: Array.from(favorites) };
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' }));
        a.download = `thai-flashcards-progress-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        showToast('Progress exported!');
    }

    function resetProgress() {
        if (confirm('Are you sure you want to reset all progress?')) {
            cardStats = {};
            sessionStats = { correct: 0, incorrect: 0, cardsReviewed: 0 };
            sessionState = { cardOrder: [], currentIndex: 0, listIndex: 0, mode: 'all', inProgress: false };
            favorites = new Set();
            localStorage.removeItem('thaiFlashcardsSession');
            saveProgress();
            currentListIndex = 0;
            vocabulary = vocabularyLists[0].words;
            updateListSelector();
            initializeCards();
            updateCard();
            showToast('Progress reset!');
            settingsModal.classList.remove('open');
        }
    }

    function saveProgress() {
        localStorage.setItem('thaiFlashcardsProgress', JSON.stringify({ 
            cardStats, 
            sessionStats, 
            currentListIndex, 
            showThaiFront, 
            currentMode, 
            favorites: Array.from(favorites),
            lastSaved: new Date().toISOString() 
        }));
    }

    function loadProgress() {
        try {
            const saved = localStorage.getItem('thaiFlashcardsProgress');
            if (saved) {
                const d = JSON.parse(saved);
                cardStats = d.cardStats || {};
                sessionStats = d.sessionStats || { correct: 0, incorrect: 0, cardsReviewed: 0 };
                currentListIndex = d.currentListIndex || 0;
                showThaiFront = d.showThaiFront !== undefined ? d.showThaiFront : true;
                currentMode = d.currentMode || 'all';
                favorites = new Set(d.favorites || []);
                toggleBtn.textContent = `üîÑ ${showThaiFront ? 'Thai' : 'English'} Front`;
                modeBtns.forEach(b => b.classList.toggle('active', b.dataset.mode === currentMode));
            }
            const sess = localStorage.getItem('thaiFlashcardsSession');
            if (sess) sessionState = JSON.parse(sess);
        } catch (e) { console.error(e); }
    }

    function showToast(msg, variant = '') {
        toast.textContent = msg;
        toast.className = 'toast show' + (variant ? ' ' + variant : '');
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.className = 'toast', 300);
        }, 2000);
    }

    init();
</script>
```

</body>
</html>